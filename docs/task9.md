# Задание 9 — Чтение с реплик (primary/secondary) и консистентность

Цель: для коллекций `products`, `orders`, `carts` определить:
- какие чтения можно отправлять на **secondary**,
- какие должны идти строго на **primary**,
- какая допустима **задержка репликации** (replication lag) для secondary-чтений,
- обоснование выбора с точки зрения консистентности и бизнес-рисков.

Термины:
- **Primary** — лидер реплика-сета (источник истины для большинства свежих данных).
- **Secondary** — реплика, которая может отставать (eventual consistency).
- `readPreference`: `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`, `nearest`
- `readConcern`: `local`, `majority` (и др.)

---

## 1) Общие принципы (перед таблицей)

1) Secondary-чтение допустимо, если:
- данные **не критичны к свежести** (допустима задержка),
- нет риска “продать то, чего нет”, “показать неверный статус”, “потерять корзину”.

2) Primary обязателен, если:
- данные участвуют в **денежной операции / резервировании остатков**,
- пользователь ожидает **моментально консистентное** поведение после своего действия,
- используется **read-your-writes** (прочитать сразу то, что записал).

3) Для secondary-чтения желательно:
- мониторить lag и автоматически переключать на primary при превышении порога,
- использовать `secondaryPreferred` (а не жесткий `secondary`) для деградации в primary при отсутствии/отставании реплик.

---

## 2) Таблица операций: куда читать и какой lag допустим

### 2.1. products

| Операция чтения | Пример запроса | Primary / Secondary | Допустимый lag на secondary | Почему |
|---|---|---:|---:|---|
| Карточка товара (описание, атрибуты, цена “на витрине”) | `findOne({_id})` | Secondary **можно** | до 5–30 сек | Описание/атрибуты меняются редко; небольшая устарелость обычно приемлема. |
| Каталог/поиск по категории/цене (витрина) | `find({category, price...})` | Secondary **можно** | до 30–120 сек | Это витринный read; часто кешируется/поисковый слой. Небольшая устарелость допустима. |
| Проверка доступности/остатка перед покупкой | чтение stock по `product_id` + geo | **Primary обязательно** | 0 сек | Риск продать отсутствующий товар. Нужна максимальная свежесть. |
| Отображение остатка в корзине/чекауте | `findOne({_id})` с stock | **Primary обязательно** | 0–1 сек (лучше 0) | На этапе оплаты/резерва критична точность. |
| “Похожие товары/рекомендации” (не критично) | выборки/агрегации | Secondary **можно** | до 60 сек | Допустима устарелость. |

**Рекомендация по параметрам:**
- для витрины: `readPreference=secondaryPreferred`, `readConcern=local`
- для чекаута/резерва: `readPreference=primary`, `readConcern=majority` (или `local`, если запись/транзакция гарантирует строгость и вы контролируете)

---

### 2.2. orders

| Операция чтения | Пример запроса | Primary / Secondary | Допустимый lag на secondary | Почему |
|---|---|---:|---:|---|
| История заказов пользователя (список) | `find({user_id}).sort({created_at:-1})` | Secondary **можно** (часто) | до 5–30 сек | Если пользователь только что оформил заказ, он может “не появиться” пару секунд — обычно допустимо при правильном UX (“обновляется”). |
| Детали старого заказа (уже доставлен/закрыт) | `findOne({_id})` | Secondary **можно** | до 30–120 сек | Исторические данные, низкая критичность. |
| Статус заказа сразу после изменения (оплата/отмена/доставка) | `findOne({_id})` | **Primary обязательно** | 0–1 сек | Пользователь ожидает мгновенный правильный статус; иначе жалобы/дубли действий. |
| Проверка заказа в процессе оплаты/подтверждения | чтение статуса/суммы | **Primary обязательно** | 0 сек | Денежная логика, риск неправильных действий/дублирования. |
| Админ/операторские отчёты “почти real-time” | агрегации | Secondary **можно** | до 60–300 сек | Если отчётность допускает задержку и не влияет на транзакции. |

**Рекомендация:**
- “витринная” история: `secondaryPreferred` + fallback на primary при lag>порог
- критичные статусы: `primary` и при необходимости `readConcern=majority`

---

### 2.3. carts

| Операция чтения | Пример запроса | Primary / Secondary | Допустимый lag на secondary | Почему |
|---|---|---:|---:|---|
| Получить активную корзину (после добавления/удаления) | `findOne({user_id,status:"active"})` | **Primary обязательно** | 0–1 сек | Нужен read-your-writes: пользователь только что изменил корзину и должен увидеть результат. |
| Получить гостевую корзину по session_id (активная) | `findOne({session_id,status:"active"})` | **Primary обязательно** | 0–1 сек | UX аналогично: “добавил товар — вижу товар”. |
| Слияние гостевой в пользовательскую | read guest + read user cart | **Primary обязательно** | 0 сек | Иначе можно потерять items/сделать двойное слияние или показать пустую корзину. |
| Просмотр корзины на витрине без изменений (редкий кейс) | `findOne(...)` | Secondary **можно**, но не рекомендовано | до 1–3 сек | Формально можно, но практическая выгода низкая, а UX-риски есть. |

**Вывод по carts:** почти все чтения должны идти на **primary**, secondary-чтение для корзины обычно не окупается из-за UX и read-your-writes.

---

## 3) Политика допустимой задержки репликации (конкретные цифры)

Рекомендуемые пороги lag для secondary-чтений (по типу данных):

- `products` витрина: **до 30 сек** (макс 120 сек для “похожих/рекомендаций”)
- `orders` история: **до 30 сек**
- `orders` статус/оплата: **0–1 сек** (по факту primary)
- `carts` активная корзина: **0–1 сек** (по факту primary)

Практически: если `lag > threshold`, автоматически:
- переключать `secondaryPreferred` → `primary` (или просто использовать `secondaryPreferred` и вводить правило “не читать secondary при lag > threshold” на уровне приложения).

---

## 4) Обоснование (консистентность, частота обновлений, бизнес-логика)

### products
- Частые обновления: **остатки** меняются постоянно.
- Риски: показать “в наличии”, когда уже нет → отмены заказов, негатив, деньги/логистика.
- Поэтому:
  - **stock / availability** — primary (макс консистентность),
  - **описание/каталог** — secondary (допустима устарелость, экономим primary).

### orders
- Частые изменения: статус меняется, но не настолько часто как корзина.
- Риски: показать неверный статус после оплаты/отмены → пользователь делает лишние действия, жалобы, спорные ситуации.
- Поэтому:
  - история/архив — secondary допустим,
  - “текущее состояние” вокруг денежных событий — primary.

### carts
- Частота обновлений максимальная, UX чувствителен.
- Критично: read-your-writes после каждого действия (добавить/удалить/сменить qty).
- Риски: “товар исчез/не добавился” → пользователь бросает покупку.
- Поэтому:
  - почти всё — primary,
  - secondary — только теоретически для редких неинтерактивных сценариев.

---

## 5) Пример настройки в приложении (на уровне драйвера)

Идея: разные readPreference для разных use-case.

- Витрина products:
  - `readPreference=secondaryPreferred`
- Чекаут/корзина/статусы:
  - `readPreference=primary`

(Конкретная реализация зависит от драйвера, но принцип именно такой.)

---

## 6) Контроль: мониторинг lag и деградация

Для принятия решений по secondary-чтению нужен мониторинг lag:
- `rs.status()` (оперативно)
- метрики лагов в мониторинге (Prometheus/Grafana)

Пример ручной проверки:
```js
rs.status().members.map(m => ({ name: m.name, state: m.stateStr, optime: m.optimeDate }))
````

---

## Итог

* `products`: secondary для витрины/каталога, primary для stock/чекаута.
* `orders`: secondary для истории/архива, primary для статусов вокруг оплаты и критичных операций.
* `carts`: почти всегда primary из-за read-your-writes и UX.
